package com.example.Recipe_Sharing_WebApplication.Controller;

import com.example.Recipe_Sharing_WebApplication.DTO.AuthRequest;
import com.example.Recipe_Sharing_WebApplication.DTO.AuthResponse;
import com.example.Recipe_Sharing_WebApplication.DTO.RefreshTokenRequest;
import com.example.Recipe_Sharing_WebApplication.DTO.RegisterRequest;
import com.example.Recipe_Sharing_WebApplication.Entity.Role;
import com.example.Recipe_Sharing_WebApplication.Entity.User;
import com.example.Recipe_Sharing_WebApplication.Repository.UserRepository;
import com.example.Recipe_Sharing_WebApplication.Service.JwtService;
import jakarta.servlet.http.Cookie;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpHeaders;
import org.springframework.http.ResponseCookie;
import org.springframework.http.ResponseEntity;
import org.springframework.security.authentication.*;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.web.bind.annotation.*;

import jakarta.annotation.PostConstruct;

@RestController
@RequestMapping("/api/auth")
@RequiredArgsConstructor
public class AuthController {

    private final AuthenticationManager authenticationManager;
    private final UserRepository userRepository;
    private final PasswordEncoder passwordEncoder;
    private final JwtService jwtService;

    private static final String ADMIN_USERNAME = "kiruba";
    private static final String ADMIN_PASSWORD = "123";

    @PostConstruct
    public void initAdmin() {
        if (userRepository.findByUsername(ADMIN_USERNAME).isEmpty()) {
            User admin = User.builder()
                    .username(ADMIN_USERNAME)
                    .password(passwordEncoder.encode(ADMIN_PASSWORD))
                    .role(Role.ADMIN)
                    .build();
            userRepository.save(admin);
        }
    }

    @PostMapping("/register")
    public ResponseEntity<String> register(@RequestBody RegisterRequest request) {
        if (userRepository.findByUsername(request.getUsername()).isPresent()) {
            return ResponseEntity.badRequest().body("Username already exists!");
        }

        User user = User.builder()
                .username(request.getUsername())
                .password(passwordEncoder.encode(request.getPassword()))
                .role(Role.USER)
                .build();

        userRepository.save(user);
        return ResponseEntity.ok("User registered successfully!");
    }

    @PostMapping("/login")
    public ResponseEntity<AuthResponse> login(
            @RequestBody AuthRequest request,
            HttpServletResponse response) {

        authenticationManager.authenticate(
                new UsernamePasswordAuthenticationToken(request.getUsername(), request.getPassword())
        );

        User user = userRepository.findByUsername(request.getUsername())
                .orElseThrow(() -> new RuntimeException("User not found"));

        String accessToken = jwtService.generateToken(user);
        String refreshToken = jwtService.generateRefreshToken(user);

        // ✅ Set secure HttpOnly cookie for refresh token
        ResponseCookie refreshCookie = ResponseCookie.from("refreshToken", refreshToken)
                .httpOnly(true)
                .secure(false)  // ✅ Change to true when using HTTPS
                .sameSite("Strict")
                .path("/api/auth")
                .maxAge(7 * 24 * 60 * 60)
                .build();

        response.addHeader(HttpHeaders.SET_COOKIE, refreshCookie.toString());

        return ResponseEntity.ok(new AuthResponse(accessToken, null)); // No more JSON refresh token
    }

    @PostMapping("/refresh")
    public ResponseEntity<AuthResponse> refresh(
            HttpServletRequest request,
            HttpServletResponse response) {

        // ✅ Read refresh token from cookie (not JSON body anymore)
        String refreshToken = null;
        if (request.getCookies() != null) {
            for (Cookie cookie : request.getCookies()) {
                if ("refreshToken".equals(cookie.getName())) {
                    refreshToken = cookie.getValue();
                }
            }
        }

        if (refreshToken == null) {
            return ResponseEntity.status(401).body(null);
        }

        String username = jwtService.extractUsername(refreshToken);
        User user = userRepository.findByUsername(username)
                .orElseThrow();

        if (!jwtService.isTokenValid(refreshToken, user)) {
            return ResponseEntity.status(401).body(null);
        }

        // ✅ Generate new tokens
        String newAccessToken = jwtService.generateToken(user);
        String newRefreshToken = jwtService.generateRefreshToken(user);

        // ✅ Update cookie
        ResponseCookie refreshCookie = ResponseCookie.from("refreshToken", newRefreshToken)
                .httpOnly(true)
                .secure(false)
                .sameSite("Strict")
                .path("/api/auth")
                .maxAge(7 * 24 * 60 * 60)
                .build();

        response.addHeader(HttpHeaders.SET_COOKIE, refreshCookie.toString());

        return ResponseEntity.ok(new AuthResponse(newAccessToken, null));
    }

    @PostMapping("/logout")
    public ResponseEntity<String> logout(HttpServletResponse response) {
        // ✅ Delete the cookie
        ResponseCookie deleteCookie = ResponseCookie.from("refreshToken", "")
                .httpOnly(true)
                .secure(false)
                .sameSite("Strict")
                .path("/api/auth")
                .maxAge(0)
                .build();

        response.addHeader(HttpHeaders.SET_COOKIE, deleteCookie.toString());

        return ResponseEntity.ok("Logged out");
    }
}package com.example.Recipe_Sharing_WebApplication.Controller;

import com.example.Recipe_Sharing_WebApplication.DTO.RecipeDTO;
import com.example.Recipe_Sharing_WebApplication.Entity.Recipe;
import com.example.Recipe_Sharing_WebApplication.Service.RecipeService;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/recipes")
@RequiredArgsConstructor
public class RecipeController {

    private final RecipeService recipeService;

//    @GetMapping
//    public Page<RecipeDTO> all(@RequestParam(defaultValue = "0") int page,
//                               @RequestParam(defaultValue = "10") int size) {
//        return recipeService.findAll(PageRequest.of(page, size));
//    }


    @GetMapping
    public Page<RecipeDTO> all(
            @RequestParam(name = "page", defaultValue = "0") int page,
            @RequestParam(name = "size", defaultValue = "10") int size,
            @RequestParam(name = "title", required = false) String title,
            @RequestParam(name = "category", required = false) String category
    ) {
        if (title != null || category != null) {
            return recipeService.search(title, category, PageRequest.of(page, size));
        }
        return recipeService.findAll(PageRequest.of(page, size));
    }


    @GetMapping("/{id}")
    public ResponseEntity<RecipeDTO> get(@PathVariable Long id) {
        return recipeService.findById(id)
                .map(ResponseEntity::ok)
                .orElse(ResponseEntity.notFound().build());
    }

    @PostMapping
    @PreAuthorize("isAuthenticated()") // any logged-in user can create
    public ResponseEntity<RecipeDTO> create(@RequestBody @Valid Recipe recipe) {
        return ResponseEntity.status(201).body(recipeService.create(recipe));
    }

    @PutMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN') or @recipeService.isOwner(#id)")
    public ResponseEntity<?> update(@PathVariable Long id, @RequestBody @Valid Recipe recipe) {
        return recipeService.update(id, recipe)
                .map(ResponseEntity::ok)
                .orElse(ResponseEntity.notFound().build());
    }

    @DeleteMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN') or @recipeService.isOwner(#id)")
    public ResponseEntity<?> delete(@PathVariable Long id) {
        return recipeService.delete(id) ?
                ResponseEntity.ok().build() :
                ResponseEntity.notFound().build();
    }

//    @GetMapping("/search")
//    public Page<RecipeDTO> search(@RequestParam(required = false) String title,
//                                  @RequestParam(required = false) String category,
//                                  @RequestParam(defaultValue = "0") int page,
//                                  @RequestParam(defaultValue = "10") int size) {
//        return recipeService.search(title, category, PageRequest.of(page, size));
//    }

    @GetMapping("/search")
    public Page<RecipeDTO> search(
            @RequestParam(name = "title", required = false) String title,
            @RequestParam(name = "category", required = false) String category,
            @RequestParam(name = "page", defaultValue = "0") int page,
            @RequestParam(name = "size", defaultValue = "10") int size
    ) {
        return recipeService.search(title, category, PageRequest.of(page, size));
    }
}package com.example.Recipe_Sharing_WebApplication.Controller;

import com.example.Recipe_Sharing_WebApplication.DTO.FavoriteRecipeDTO;
import com.example.Recipe_Sharing_WebApplication.Service.FavoriteService;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/favorites")
@RequiredArgsConstructor
public class FavoriteController {

    private final FavoriteService favoriteService;

    @PostMapping("/{recipeId}")
    public ResponseEntity<String> addFavorite(@PathVariable Long recipeId) {
        favoriteService.addFavorite(recipeId);
        return ResponseEntity.status(201).body("Recipe added to favorites!");
    }

    @DeleteMapping("/{recipeId}")
    public ResponseEntity<String> removeFavorite(@PathVariable Long recipeId) {
        favoriteService.removeFavorite(recipeId);
        return ResponseEntity.ok("Recipe removed from favorites!");
    }

    @GetMapping
    public ResponseEntity<List<FavoriteRecipeDTO>> getUserFavorites() {
        return ResponseEntity.ok(favoriteService.getUserFavorites());
    }
}const API_URL = 'http://localhost:8080/api';
let currentPage = 0;
const pageSize = 8;
let lastPage = 0;

const LS = {
  title: 'rs_searchTitle',
  category: 'rs_searchCategory',
  page: 'rs_currentPage'
};

// Elements
const searchTitle = document.getElementById('search-title');
const searchCategory = document.getElementById('search-category');
const recipeList = document.getElementById('recipe-list');
const favoritesList = document.getElementById('favorites-list');
const pageInfo = document.getElementById('page-info');
const spinner = document.getElementById('loading-spinner');
const modal = document.getElementById('modal');
const modalBody = document.getElementById('modal-body');
const modalClose = document.getElementById('modal-close');
const toastRoot = document.getElementById('toast-root');
const btnCreate = document.getElementById('btn-create');
const btnLogin = document.getElementById('btn-login');
const btnRegister = document.getElementById('btn-register');
const btnLogout = document.getElementById('btn-logout');
const currentUserSpan = document.getElementById('current-user');

function getToken() { return localStorage.getItem('accessToken'); }
function setToken(t) { localStorage.setItem('accessToken', t); }
function clearToken() { localStorage.removeItem('accessToken'); }
function authHeaders() {
  const t = getToken();
  return t ? { 'Authorization': 'Bearer ' + t } : {};
}

function showSpinner() { spinner.classList.remove('hidden'); }
function hideSpinner() { spinner.classList.add('hidden'); }

function showToast(msg, type='success') {
  const t = document.createElement('div');
  t.className = `toast ${type}`;
  t.textContent = msg;
  toastRoot.appendChild(t);
  requestAnimationFrame(()=>t.classList.add('show'));
  setTimeout(()=>{t.classList.remove('show'); setTimeout(()=>t.remove(),300)},2800);
}

function openModal(html) {
  modalBody.innerHTML = html;
  modal.classList.remove('hidden');
  document.body.style.overflow='hidden';
}
function closeModal() {
  modal.classList.add('hidden');
  modalBody.innerHTML = '';
  document.body.style.overflow='';
}
modalClose.addEventListener('click', closeModal);
modal.addEventListener('click', e=>{if(e.target===modal)closeModal();});

async function apiFetch(url, options={}) {
  options.headers = {...(options.headers||{}), ...authHeaders()};
  let res = await fetch(url, options);
  if(res.status===401){
    const refresh = await fetch(`${API_URL}/auth/refresh`, {method:'POST',credentials:'include'});
    if(refresh.ok){
      const data = await refresh.json();
      if(data.accessToken) setToken(data.accessToken);
      options.headers = {...(options.headers||{}), ...authHeaders()};
      res = await fetch(url, options);
    } else {
      clearToken(); refreshAuthUI();
    }
  }
  return res;
}

function escapeHtml(s){return s?String(s).replace(/[&<>"]/g,c=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;'}[c])):'';}

// ======== Auth UI ========
function refreshAuthUI(){
  const token = getToken();
  if(!token){
    currentUserSpan.textContent='';
    btnLogin.style.display='';
    btnRegister.style.display='';
    btnLogout.style.display='none';
    btnCreate.style.display='none';
    favoritesList.innerHTML='(login to view)';
  } else {
    try {
      const payload = JSON.parse(atob(token.split('.')[1]));
      currentUserSpan.textContent='Hi, '+(payload.sub||payload.username||'user');
    }catch(e){currentUserSpan.textContent='Hi, user';}
    btnLogin.style.display='none';
    btnRegister.style.display='none';
    btnLogout.style.display='';
    btnCreate.style.display='';
    loadFavorites();
  }
}

btnLogout.addEventListener('click', async ()=>{
  try{await fetch(`${API_URL}/auth/logout`,{method:'POST',credentials:'include'});}catch{}
  clearToken(); refreshAuthUI(); showToast('Logged out');
});

btnLogin.addEventListener('click', ()=>showAuthModal('login'));
btnRegister.addEventListener('click', ()=>showAuthModal('register'));

function showAuthModal(type){
  openModal(`
    <h3>${type==='login'?'Login':'Register'}</h3>
    <div class="form-row"><label>Username</label><input id="auth-username"/></div>
    <div class="form-row"><label>Password</label><input id="auth-password" type="password"/></div>
    <div style="text-align:right;margin-top:12px;">
      <button id="auth-submit" class="btn primary">${type==='login'?'Login':'Register'}</button>
      <button id="auth-cancel" class="btn ghost">Cancel</button>
    </div>
  `);
  document.getElementById('auth-cancel').onclick=closeModal;
  document.getElementById('auth-submit').onclick=()=>submitAuth(type);
}

async function submitAuth(type){
  const username=document.getElementById('auth-username').value.trim();
  const password=document.getElementById('auth-password').value;
  if(!username||!password){showToast('All fields required','warning');return;}
  try{
    const res=await fetch(`${API_URL}/auth/${type}`,{
      method:'POST',headers:{'Content-Type':'application/json'},
      body:JSON.stringify({username,password}),credentials:'include'
    });
    if(!res.ok){throw new Error(`${type} failed`);}
    const data=await res.json();
    if(data.accessToken){setToken(data.accessToken);}
    closeModal(); refreshAuthUI(); loadRecipes();
    showToast(`${type==='login'?'Logged in':'Registered successfully'}`,'success');
  }catch(e){showToast(e.message,'error');}
}

// ======== Search & Pagination ========
let searchTimeout;
searchTitle.addEventListener('input',()=>{clearTimeout(searchTimeout);searchTimeout=setTimeout(()=>{currentPage=0;loadRecipes();},500);});
searchCategory.addEventListener('change',()=>{currentPage=0;loadRecipes();});
document.getElementById('prev-page').addEventListener('click',()=>{if(currentPage>0){currentPage--;loadRecipes();}});
document.getElementById('next-page').addEventListener('click',()=>{if(currentPage<lastPage){currentPage++;loadRecipes();}});

// ======== Load Recipes ========
async function loadRecipes(){
  const title=encodeURIComponent(searchTitle.value||'');
  const cat=encodeURIComponent(searchCategory.value||'');
  const url=`${API_URL}/recipes?page=${currentPage}&size=${pageSize}${title?`&title=${title}`:''}${cat?`&category=${cat}`:''}`;
  showSpinner();
  try{
    const res=await apiFetch(url);
    if(!res.ok){recipeList.innerHTML='<div class="card">Load failed</div>';return;}
    const page=await res.json();
    const content=page.content||page;
    recipeList.innerHTML=content.map(r=>`
      <div class="recipe-card" data-id="${r.id}">
        <h4>${escapeHtml(r.title)}</h4>
        <div class="recipe-meta">${escapeHtml(r.category)} • by ${escapeHtml(r.authorUsername)}</div>
        <div class="recipe-desc">${escapeHtml((r.description||'').slice(0,100))}</div>
      </div>
    `).join('')||'<div class="card">No recipes</div>';
    lastPage=(page.totalPages||1)-1;
    pageInfo.textContent=`Page ${page.number+1} of ${page.totalPages}`;
    document.querySelectorAll('.recipe-card').forEach(el=>{
      el.addEventListener('click',()=>loadRecipeDetail(el.dataset.id));
    });
  }catch{recipeList.innerHTML='<div class="card">Error loading</div>';}
  finally{hideSpinner();}
}

// ======== Recipe Detail (in modal) ========
async function loadRecipeDetail(id){
  openModal('<p>Loading...</p>');
  try{
    const res=await apiFetch(`${API_URL}/recipes/${id}`);
    if(!res.ok){modalBody.innerHTML='<p>Failed to load</p>';return;}
    const r=await res.json();
    modalBody.innerHTML=`
      <h2>${escapeHtml(r.title)}</h2>
      <p><strong>Category:</strong> ${escapeHtml(r.category)}</p>
      <p><strong>By:</strong> ${escapeHtml(r.authorUsername)}</p>
      <p><strong>Description:</strong><br>${escapeHtml(r.description||'')}</p>
      <p><strong>Instructions:</strong><br>${escapeHtml(r.instructions||'')}</p>
      <div style="margin-top:12px;text-align:right;">
        ${getToken()?`<button class="btn" id="fav-add" data-id="${r.id}">❤ Favorite</button>`:''}
      </div>
    `;
    const favBtn=document.getElementById('fav-add');
    if(favBtn){
      // Check if already favorite
      const favs = await getFavorites();
      if(favs.some(f => f.id === r.id)) favBtn.classList.add('fav-active');
      favBtn.onclick=()=>toggleFavorite(r.id, favBtn);
    }
  }catch{modalBody.innerHTML='<p>Error loading recipe</p>';}
}

// ======== Favorites ========
async function getFavorites(){
  try{
    const res=await apiFetch(`${API_URL}/favorites`);
    if(!res.ok) return [];
    return await res.json();
  }catch{return [];}
}

async function loadFavorites(){
  try{
    const res=await apiFetch(`${API_URL}/favorites`);
    if(!res.ok){favoritesList.innerHTML='(error)';return;}
    const favs=await res.json();
    favoritesList.innerHTML=favs.length?favs.map(f=>`
      <li>
        <span class="fav-title" data-id="${f.id}" style="cursor:pointer">${escapeHtml(f.title)}</span>
        <button class="fav-remove" data-id="${f.id}">×</button>
      </li>`).join(''):'(none)';
    favoritesList.querySelectorAll('.fav-remove').forEach(btn=>{
      btn.onclick=()=>removeFavorite(btn.dataset.id);
    });
    favoritesList.querySelectorAll('.fav-title').forEach(span=>{
      span.onclick=()=>loadRecipeDetail(span.dataset.id);
    });
  }catch{favoritesList.innerHTML='(error)';}
}

async function toggleFavorite(id, btn){
  try{
    const res=await apiFetch(`${API_URL}/favorites/${id}`,{method:'POST'});
    if(res.ok){
      btn.classList.toggle('fav-active');
      if(btn.classList.contains('fav-active')) showToast('Added to favorites');
      else showToast('Removed from favorites');
      loadFavorites();
    } else showToast('Failed','error');
  }catch{showToast('Failed','error');}
}

async function removeFavorite(id){
  try{
    const res=await apiFetch(`${API_URL}/favorites/${id}`,{method:'DELETE'});
    if(!res.ok)throw new Error('Failed');
    showToast('Removed'); loadFavorites();
  }catch{showToast('Remove failed','error');}
}

// ======== Categories ========
async function loadCategories(){
  try{
    const res=await fetch(`${API_URL}/recipes/categories`);
    if(res.ok){
      const cats=await res.json();
      searchCategory.innerHTML='<option value="">All categories</option>'+cats.map(c=>`<option value="${c}">${c}</option>`).join('');
      window.allCategories = cats;
    }
  }catch{}
}

// ======== Recipe Form ========
btnCreate.addEventListener('click',()=>showRecipeForm());
function showRecipeForm(recipe){
  const catOptions = (window.allCategories||[]).map(c =>
    `<option value="${c}" ${recipe?.category===c?'selected':''}>${c}</option>`
  ).join('');
  openModal(`
    <h3>${recipe?'Edit':'Create'} Recipe</h3>
    <div class="form-row"><label>Title</label><input id="r-title" value="${escapeHtml(recipe?.title||'')}"></div>
    <div class="form-row"><label>Category</label>
      <select id="r-category">${catOptions}</select>
    </div>
    <div class="form-row"><label>Description</label><textarea id="r-description">${escapeHtml(recipe?.description||'')}</textarea></div>
    <div class="form-row"><label>Instructions</label><textarea id="r-instructions">${escapeHtml(recipe?.instructions||'')}</textarea></div>
    <div style="text-align:right;margin-top:12px;">
      <button id="r-submit" class="btn primary">${recipe?'Update':'Create'}</button>
      <button id="r-cancel" class="btn ghost">Cancel</button>
    </div>
  `);
  document.getElementById('r-cancel').onclick=closeModal;
  document.getElementById('r-submit').onclick=()=>submitRecipeForm(recipe?.id);
}

async function submitRecipeForm(id){
  const title=document.getElementById('r-title').value.trim();
  const category=document.getElementById('r-category').value.trim();
  const description=document.getElementById('r-description').value.trim();
  const instructions=document.getElementById('r-instructions').value.trim();
  if(!title||!category){showToast('Title & Category required','warning');return;}
  const body=JSON.stringify({title,category,description,instructions});
  const method=id?'PUT':'POST';
  const url=id?`${API_URL}/recipes/${id}`:`${API_URL}/recipes`;
  try{
    const res=await apiFetch(url,{method,headers:{'Content-Type':'application/json'},body});
    if(!res.ok)throw new Error('Save failed');
    closeModal(); showToast('Recipe saved'); loadRecipes();
  }catch(e){showToast(e.message,'error');}
}

// ======== Init ========
(async ()=>{
  searchTitle.value=localStorage.getItem(LS.title)||'';
  searchCategory.value=localStorage.getItem(LS.category)||'';
  currentPage=parseInt(localStorage.getItem(LS.page)||0);
  await loadCategories();
  refreshAuthUI();
  await loadRecipes();
})();
window.addEventListener('beforeunload',()=>{
  localStorage.setItem(LS.title,searchTitle.value);
  localStorage.setItem(LS.category,searchCategory.value);
  localStorage.setItem(LS.page,currentPage);
});

package com.example.Recipe_Sharing_WebApplication.Entity;

import com.fasterxml.jackson.annotation.JsonIdentityInfo;
import com.fasterxml.jackson.annotation.ObjectIdGenerators;
import jakarta.persistence.*;
import lombok.*;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;

import java.util.Collection;
import java.util.HashSet;
import java.util.Set;

@Entity
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
@Table(name = "users")
@JsonIdentityInfo(
        generator = ObjectIdGenerators.PropertyGenerator.class,
        property = "id"
)
public class User implements UserDetails {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(unique = true, nullable = false)
    private String username;

    @Column(nullable = false)
    private String password;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private Role role;

    @OneToMany(mappedBy = "author", cascade = CascadeType.ALL, orphanRemoval = true)
    @Builder.Default
    private Set<Recipe> recipes = new HashSet<>();

    @OneToMany(mappedBy = "user", cascade = CascadeType.ALL, orphanRemoval = true)
    @Builder.Default
    private Set<Favorite> favorites = new HashSet<>();

    @Override
    public Collection<? extends GrantedAuthority> getAuthorities() {
        return Set.of(new SimpleGrantedAuthority(role.name()));
    }

    @Override
    public boolean isAccountNonExpired() { return true; }

    @Override
    public boolean isAccountNonLocked() { return true; }

    @Override
    public boolean isCredentialsNonExpired() { return true; }

    @Override
    public boolean isEnabled() { return true; }
}
package com.example.Recipe_Sharing_WebApplication.Entity;

import com.fasterxml.jackson.annotation.JsonIdentityInfo;
import com.fasterxml.jackson.annotation.ObjectIdGenerators;
import jakarta.persistence.*;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
import lombok.*;
import org.hibernate.annotations.CreationTimestamp;

import java.time.LocalDateTime;
import java.util.HashSet;
import java.util.Set;

@Entity
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
@JsonIdentityInfo(
        generator = ObjectIdGenerators.PropertyGenerator.class,
        property = "id"
)
public class Recipe {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @NotBlank(message = "Title cannot be blank")
    @Column(nullable = false, length = 100)
    private String title;

    @Lob
    @Size(max = 5000, message = "Description cannot exceed 5000 characters")
    private String description;

    @Enumerated(EnumType.STRING)
    @Column(length = 50, nullable = false)
    private Category category;

    @CreationTimestamp
    private LocalDateTime createdAt;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id", nullable = false)
    private User author;

    @OneToMany(mappedBy = "recipe", cascade = CascadeType.ALL, orphanRemoval = true)
    @Builder.Default
    private Set<Favorite> favorites = new HashSet<>();
}
package com.example.Recipe_Sharing_WebApplication.Entity;

import com.fasterxml.jackson.annotation.JsonIdentityInfo;
import com.fasterxml.jackson.annotation.ObjectIdGenerators;
import jakarta.persistence.*;
import lombok.*;
import org.hibernate.annotations.CreationTimestamp;

import java.time.LocalDateTime;

@Entity
@Table(name = "favorites", uniqueConstraints = {
        @UniqueConstraint(columnNames = {"user_id", "recipe_id"})
})
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
@JsonIdentityInfo(
        generator = ObjectIdGenerators.PropertyGenerator.class,
        property = "id"
)
public class Favorite {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id", nullable = false)
    private User user;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "recipe_id", nullable = false)
    private Recipe recipe;

    @CreationTimestamp
    private LocalDateTime favoritedAt;
}
package com.example.Recipe_Sharing_WebApplication.Service;




import com.example.Recipe_Sharing_WebApplication.Entity.User;
import com.example.Recipe_Sharing_WebApplication.Repository.UserRepository;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;

@Service
public class UserService {
    public final UserRepository userRepository;
    public final PasswordEncoder passwordEncoder;


    public UserService(UserRepository userRepository, PasswordEncoder passwordEncoder){
        this.userRepository=userRepository;
        this.passwordEncoder=passwordEncoder;
    }

    public User RegisterUser(String username, String password){
        String hashedPassword= passwordEncoder.encode(password);
        User user =new User();
        user.setUsername(username);
        user.setPassword(hashedPassword);
        return userRepository.save(user);
    }
}

package com.example.Recipe_Sharing_WebApplication.Service;

import com.example.Recipe_Sharing_WebApplication.DTO.RecipeDTO;
import com.example.Recipe_Sharing_WebApplication.Entity.Recipe;
import com.example.Recipe_Sharing_WebApplication.Entity.User;
import com.example.Recipe_Sharing_WebApplication.Repository.RecipeRepository;
import com.example.Recipe_Sharing_WebApplication.Repository.UserRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.Objects;
import java.util.Optional;

@Service
@RequiredArgsConstructor
public class RecipeService {

    private final RecipeRepository recipeRepository;
    private final UserRepository userRepository;


    public Page<RecipeDTO> findAll(Pageable pageable) {
        return recipeRepository.findAllWithAuthor(pageable).map(this::mapToDTO);
    }

    public Optional<RecipeDTO> findById(Long id) {
        return recipeRepository.findById(id).map(this::mapToDTO);
    }


    public RecipeDTO create(Recipe recipe) {
        User author = getCurrentUserFromJWT();
        recipe.setAuthor(author);
        return mapToDTO(recipeRepository.save(recipe));
    }


    public Optional<RecipeDTO> update(Long id, Recipe updates) {
        return recipeRepository.findById(id).map(existing -> {
            if (updates.getTitle() != null) existing.setTitle(updates.getTitle());
            if (updates.getDescription() != null) existing.setDescription(updates.getDescription());
            if (updates.getCategory() != null) existing.setCategory(updates.getCategory());
            return mapToDTO(recipeRepository.save(existing));
        });
    }


    public boolean delete(Long id) {
        return recipeRepository.findById(id).map(recipe -> {
            recipeRepository.delete(recipe);
            return true;
        }).orElse(false);
    }

    public Page<RecipeDTO> search(String title, String category, Pageable pageable) {
        return recipeRepository.search(title, category, pageable).map(this::mapToDTO);
    }


    public boolean isOwner(Long recipeId) {
        User currentUser = getCurrentUserFromJWT();
        return recipeRepository.findById(recipeId)
                .map(recipe -> recipe.getAuthor().getId().equals(currentUser.getId()))
                .orElse(false);
    }


    private RecipeDTO mapToDTO(Recipe recipe) {
        return new RecipeDTO(
                recipe.getId(),
                recipe.getTitle(),
                recipe.getDescription(),
                recipe.getCategory().name(),
                recipe.getAuthor().getUsername(), // ✅ This is correct
                recipe.getCreatedAt()
        );
    }


    private User getCurrentUserFromJWT() {
        Authentication auth = SecurityContextHolder.getContext().getAuthentication();
        return userRepository.findByUsername(auth.getName())
                .orElseThrow(() -> new RuntimeException("User not found"));
    }

    public List<String> getAllCategories() {
        return recipeRepository.findAll()
                .stream()
                .map(Recipe::getCategory)
                .filter(Objects::nonNull)
                .map(Enum::name)
                .distinct()
                .sorted()
                .toList();
    }


}
package com.example.Recipe_Sharing_WebApplication.Service;

import com.example.Recipe_Sharing_WebApplication.DTO.FavoriteRecipeDTO;
import com.example.Recipe_Sharing_WebApplication.Entity.Favorite;
import com.example.Recipe_Sharing_WebApplication.Entity.Recipe;
import com.example.Recipe_Sharing_WebApplication.Entity.User;
import com.example.Recipe_Sharing_WebApplication.Repository.FavoriteRepository;
import com.example.Recipe_Sharing_WebApplication.Repository.RecipeRepository;
import com.example.Recipe_Sharing_WebApplication.Repository.UserRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Service;

import java.util.List;

@Service
@RequiredArgsConstructor
public class FavoriteService {

    private final FavoriteRepository favoriteRepository;
    private final RecipeRepository recipeRepository;
    private final UserRepository userRepository;

    private User getCurrentUser() {
        Authentication auth = SecurityContextHolder.getContext().getAuthentication();
        return userRepository.findByUsername(auth.getName())
                .orElseThrow(() -> new RuntimeException("User not found"));
    }

    public void addFavorite(Long recipeId) {
        User user = getCurrentUser();
        Recipe recipe = recipeRepository.findById(recipeId)
                .orElseThrow(() -> new RuntimeException("Recipe not found"));

        if (favoriteRepository.existsByUserAndRecipe(user, recipe)) {
            throw new RuntimeException("Recipe already favorited");
        }

        Favorite favorite = new Favorite();
        favorite.setUser(user);
        favorite.setRecipe(recipe);
        favoriteRepository.save(favorite);
    }

    public void removeFavorite(Long recipeId) {
        User user = getCurrentUser();
        Recipe recipe = recipeRepository.findById(recipeId)
                .orElseThrow(() -> new RuntimeException("Recipe not found"));

        favoriteRepository.findByUserAndRecipe(user, recipe)
                .ifPresent(favoriteRepository::delete);
    }

    public List<FavoriteRecipeDTO> getUserFavorites() {
        User user = getCurrentUser();
        return favoriteRepository.findByUser(user).stream()
                .map(fav -> new FavoriteRecipeDTO(
                        fav.getRecipe().getId(),
                        fav.getRecipe().getTitle(),
                        fav.getRecipe().getCategory().name(),
                        fav.getRecipe().getAuthor().getUsername()))
                .toList();
    }
}



